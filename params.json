{
  "name": "Bun",
  "tagline": "Bun is a simple to use C++ Object Relational Mapper (ORM) library",
  "body": "# bun\r\nBun is a simple to use C++ Object Relational Mapper (ORM) library\r\n\r\n#Feature\r\n*Easy of Use\r\n*Object Persistence\r\n*EDSL Object Query Language\r\n*Compile time EDSL syntax check\r\n*Embedded Database\r\n\r\n#Usage\r\n\r\n```C++\r\n#include \"blib/bun/Bun.hpp\"\r\n\r\nnamespace test {\r\n  struct Test {\r\n    int one;\r\n    float two;\r\n    std::string three;\r\n  };\r\n\r\n  struct SomeOtherTest {\r\n    int one;\r\n    float two;\r\n    std::string three;\r\n    SomeOtherTest() = default;\r\n  };\r\n}\r\n\r\nnamespace test {\r\n  struct Person {\r\n    std::string name;\r\n    int age;\r\n    float height;\r\n  };\r\n}\r\n\r\nGENERATE_BINDING( (test::Person, name, age, height) );\r\n\r\nint main() {\r\n  namespace bun = blib::bun;\r\n  // Connect the db. If the db is not there it will be created.\r\n  // It should include the whole path\r\n  bun::dbConnect( \"test.db\" );\r\n  // Create the schema. We can create the schema multile times. If its already created\r\n  // it will be safely ignored\r\n  blib::bun::createSchema<test::Person>();\r\n\r\n  // Creat some entries in the database\r\n  for (int i = 1; i < 13; ++i) {\r\n    // PRef is a reference to the persistant object.\r\n    // PRef keeps the ownership of the memory. Release the memory when it is destroyed.\r\n    // Internally it holds the object in a unique_ptr\r\n    // PRef also has a oid associated with the object\r\n    bun::PRef<test::Person> p = new test::Person;\r\n\r\n    // Assign the members values\r\n    p->age = i + 10;\r\n    p->height = 5.6;\r\n    p->name = fmt::format( \"Brainless_{}\", i );\r\n    // Persist the object and get a oid for the persisted object.\r\n    const blib::bun::SimpleOID oid = p.persist();\r\n\r\n    //Getting the object from db using oid.\r\n    bun::PRef<test::Person> p1( oid );\r\n  }\r\n\r\n  // To get all the object oids of a particular object.\r\n  // person_oids is a vector of type std::vector<blib::bun<>SimpleOID<test::Person>>\r\n  const auto person_oids = blib::bun::getAllOids<test::Person>();\r\n\r\n  // To get the objects of a particular type\r\n  // std::vector<blib::bun::Pref<test::Person>>\r\n  const auto person_objs = blib::bun::getAllObjects<test::Person>();\r\n\r\n  // EDSL QUERY LANGUAGE ----------------------\r\n  // Powerful EDSL object query syntax that is checked for syntax at compile time.\r\n  // The compilation fails at the compile time with a message \"Syntax error in Bun Query\"\r\n  bun::query::From<test::Person> FromPerson;\r\n  // Grammar are checked for validity of syntax at compile time itself.\r\n  // Currently only &&, ||, <, <=, >, >=, ==, != are supported. They have their respective meaning\r\n  // Below is a valid query grammar\r\n  auto valid_query = bun::query::F<test::Person>::age > 10 && bun::query::F<test::Person>::name != \"Brainless_0\";\r\n  std::cout << \"Valid Grammar?: \" << blib::bun::query::IsValidQuery<decltype(valid_query)>::value << std::endl;\r\n\r\n  // Oops + is not a valid grammar\r\n  auto invalid_query = bun::query::F<test::Person>::age + 10 && bun::query::F<test::Person>::name != \"Brainless_0\";\r\n  std::cout << \"Valid Grammar?: \" << blib::bun::query::IsValidQuery<decltype(invalid_query)>::value << std::endl;\r\n\r\n  // Now let us execute the query.\r\n  // The where function also checks for the validity of the query, and fails at compile time\r\n  const auto objs = FromPerson.where( valid_query ).objects();\r\n\r\n  // Not going to compile if you enable the below line. Will get the \"Syntax error in Bun Query\" compile time message.\r\n  //const auto objs1 = FromPerson.where( invalid_query ).objects();\r\n\r\n  // Check the query generated. It does not give the sql query.\r\n  std::cout << FromPerson.query() << std::endl;\r\n  return 0;\r\n}\r\n```\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}